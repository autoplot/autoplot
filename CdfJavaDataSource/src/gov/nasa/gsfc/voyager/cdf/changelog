version 0.9
Fixed the problem with attribute values of type EPOCH16. The revised code 
returns double[nelement*2] array. 

0. CDFImpl changes are listed in the diff CDFImpl_changes.
 
1. TimeSeries is a new interface for a basic time series. It has become necessary because double[][] is not sufficient to specify the attributes of times returned. The getTimeSeriesObject methods of CDF return a time series object.

2. Extractor changes are related to the extended precision time.

3. TimeVariable interface was augmented with the following methods that allow extraction of times conforming to the base and offset specified by the TimeSpec interface.
    public double[] getTimes(TimeSpec ts) throws Throwable;
    public double [] getTimes(int[] recordRange, TimeSpec ts);
    public double [] getTimes(double[] timeRange, TimeSpec ts);
    public int[] getRecordRange(double[] timeRange, TimeSpec ts) throws
    Throwable;

4. Added interface TimeSpec to return times relative to a base time in desired units. With the addition of TT2000 times, the existing scheme of returning times as doubles is inadequate.


5. Variable.java: added method getPadValue(boolean preservePrecision) to return pad value as objects that preserve the precision of the value specified. Existing method getPadValue() (eqivalent to getPadValue(false)) returned doubles for all numeric types.

6. CDF.java comments were modified to explain the addition of long variables.

7. DataTypes.java: added type LONG and  CDF_TIME_TT2000
Version 0.8
Added a method to Variable Interface to return data buffers for the variable.
public VariableDataBuffer[] getDataBuffers() throws Throwable;
This makes it possible for an application to get the ByteBuffers without 
the knowledge of the primary ByteBuffer.
VariableDataBuffer class has methods that return attributes of each buffer.
Added getDataBuffers method to CDFImpl

Version 0.5
    Addresses a feature in CDFs generated using the cdf library. In certain
cases the Variable Descriptor record may indicate that the data for a variable
is compressed, but the actual data may not be compressed if the library
determines that the uncompressed data is of smaller size than the compressed
data would be. This condition typically occurs for variables which are not
record variant.
Previous version of this package would fail when this feature was present,
because it would look for a variable value record with the signature of CVVR
if the descriptor indicated that the variable is compressed.
